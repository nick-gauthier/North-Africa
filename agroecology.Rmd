---
title: "Agroecology_dyn"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(raster)
library(tidyverse)
library(mgcv)
```

```{r}
bbox <- extent(5, 11.5, 34, 37.5)
```

```{r}
elev <- raster('~/gdrive/Data/SRTM_1km.tif') %>% crop(bbox)
elev_dat <- as.data.frame(elev, xy =  T, na.rm = T) %>%
  rename(elev = SRTM_1km)

ggplot(elev_dat, aes(x, y)) +
  geom_raster(aes(fill = elev)) +
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Meters') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Elevation', subtitle = 'Africa Proconsularis')
```

```{r}
slope <- terrain(srtm, opt = 'slope', unit = 'degrees')
slope_dat <- as.data.frame(slope, xy = T, na.rm = T)

ggplot(slope_dat, aes(x, y)) +
  geom_raster(aes(fill = slope)) +
  scale_fill_viridis(name = 'Degrees', option = 'B') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Slope', subtitle = 'Africa Proconsularis')
```

```{r}
focalWeight(slope < 5, 0.008333333 * 2, type = 'circle') %>%
  focal(slope < 5, ., sum) %>%
  as.data.frame(xy = T, na.rm = T) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = layer)) +
  scale_fill_viridis(name = 'Proportion \narable land') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Arable land', subtitle = 'Africa Proconsularis')
```

```{r climate, cache = T}
import_chelsa <- function(x){
  list.files(x, full.names = T) %>% 
  stack %>%
  crop(bbox) %>%
  .[[c(1,5:12, 2:4)]]
}
prec <- import_chelsa('/media/nick/0327ee2a-8256-411c-8b81-4f099c20a7cf/CHELSA/prec/')
temp <- import_chelsa('/media/nick/0327ee2a-8256-411c-8b81-4f099c20a7cf/CHELSA/temp/') %>%
  `/`(10)

levelplot(prec)
levelplot(temp)
```

```{r}
gdd5_interp <- function(x){
  if(any(is.na(x))){return(NA)} else{
    daily <- gam(x ~ s(doy, bs = 'cc', k = 12), knots = list(doy = c(1, 366))) %>%
      predict.gam(data.frame(doy = 1:365)) 
    daily[daily < 5] <- 5
    return(sum(daily - 5))
  }
}

doy <-c(15, 46, 74, 105, 135, 166, 196, 227, 258, 288, 319, 349)
```

```{r eval = F}
beginCluster(4)
gdd5 <- clusterR(temp, calc, args = list(fun = gdd5_interp), export = 'doy')
endCluster()
writeRaster(gdd5, 'data/CHELSA/gdd5_1km.tif', overwrite = T)
```

```{r}
gdd5 <- raster('data/CHELSA/gdd5_1km.tif')
rasterVis::levelplot(gdd5)

plot(gdd5, mean(temp))
```

# Social Model
##Parameters
```{r}
calorie.req <- 202.5 #212  # kg of wheat to feed a person for 1 year, assuming grain is 75% of diet
seed.req <- 135  #108 # kg of wheat to sow a hectare
yield <- seed.req * 4   # kg of wheat yield per hectare, based on 4:1 yields
```

Create a 2 villages of 10 households with 6 people in each.
```{r}
init_settlements <- 10 
init_households <- 50
init_inhabitants <- 6
init_age <- 25

create.households <- function(x){
  tibble(household = 1:x,
         n_inhabitants = init_inhabitants,
         storage = n_inhabitants * calorie.req,
         food_ratio = 1) %>%
    mutate(inhabitants = map(n_inhabitants, create.inhabitants))
}

create.inhabitants <- function(x){
  tibble(age = rep(25, x))
}

population <- tibble(settlement = 1:init_settlements,
                     households = init_households) %>%
              mutate(households = map(households, create.households))
```

Try an alternative way, instead of having nested lists, just have three tables with keys
```{r}
pop <- tibble(settlement = 1:init_settlements,
                     households = init_households)

population %>% unnest
pop %>% mutate(map(households, create.households)) #%>% bind_rows
```


```{r}
eat <- function(households, harvest){
  food.req <- calorie.req * nrow(inhabitants)
  households %>%
    mutate(food.ratio = (storage + harvest)/ food.req) %>%
    mutate(old.storage = storage,
           storage = if_else(food.req <= storage, harvest, max(harvest - (food.req - old.storage), 0))) %>%
    select(-old.storage)
}
```

```{r birth-death}
fertility_table <- tibble(
  age = seq(10, 45, 5),
  rate = c(0.022, 0.232, 0.343, 0.367, 0.293, 0.218, 0.216, 0.134)
)


mortality_table <- tibble(
  age = c(0, 1, seq(5, 80, 5)),
  rate = c(0.4669, 0.0702, 0.0132, 0.0099, 0.0154, 0.0172, 0.0195, 0.0223, 0.0259, 0.0306, 0.0373, 0.0473, 0.0573, 0.0784, 0.1042, 0.1434, 0.2039, 0.2654)
)

ggplot(mortality_table, aes(age, rate)) +
  geom_line(color = 'red') +
  geom_line(data = fertility_table, color = 'blue') +
  labs(title = 'Fertility and Mortality Rates', subtitle = 'Per capita fertility (blue) and mortality (red) in the Roman Empire', x = 'Age', y = 'Vital rate') +
  theme_bw()
```

```{r vital-rate-elasticity}
fertility_elasticity <- read_csv('data/fertility_data.csv', skip = 1) %>% 
  rename(food_ratio = X, fertility_reduction = Y) %>%
  gam(fertility_reduction ~ s(food_ratio), dat = .)

mort_table <- read_csv('data/mortality_dataset.csv', skip = 1)

survivorship_elasticity <- bind_rows(
    mort_table[1:2] %>% mutate(age = 1) %>% rename(food_ratio = X, mortality_reduction = Y), 
    mort_table[3:4] %>% mutate(age = 25) %>% rename(food_ratio = X_1, mortality_reduction = Y_1),
    mort_table[5:6] %>% mutate(age = 5) %>% rename(food_ratio = X_2, mortality_reduction = Y_2),
    mort_table[7:8] %>% mutate(age = 65) %>% rename(food_ratio = X_3, mortality_reduction = Y_3)
  ) %>%
  group_by(age) %>%
  nest %>% 
  mutate(model = map(data, ~gam(mortality_reduction ~ s(food_ratio), dat = .))) %>%
  select(-data)
rm(mort_table) 

plot(fertility_elasticity)
walk(survivorship_elasticity$model, plot, pages = 1)
```

```{r reproduction}
reproduce <- function(inhabitants, food_ratio){
  fertility_reduction <- ifelse(food_ratio >= 1, 1, predict(fertility_elasticity, list(food_ratio = food_ratio)))
  
  babies <- inhabitants %>%
    filter(age >= 12 & age < 50) %>%   # only individuals of child bearing age reproduce
    inner_join(fertility_table, by = 'age') %>%    # find the fertility rate corresponding to the individual's age
    mutate(baby = (rate / 2 * fertility_reduction) > runif(n())) %>%  # divide by two to make everyone female ...
    .$baby %>% # select just the babies column
    sum  # add it up to determine the number of newborns in the house
  
  if(babies > 0) inhabitants <- add_row(inhabitants, age = rep(0, babies))
  return(inhabitants)
}
```

```{r}
die <- function(inhabitants, food_ratio){
  inhabitants %>%
    inner_join(mortality_table, by = 'age') %>%
    inner_join(survivorship_elasticity, by = 'age') %>%
    mutate(survivorship_reduction = ifelse(food_ratio >= 1, 1, map_dbl(model, ~predict(.x, list(food_ratio = food_ratio)))),
           dead = ((1 - rate) * survivorship_reduction) < runif(n())) %>%
    filter(dead == F) %>%
    select(age)
}
```


```{r}
birth_death <- function(household){
  household %>%
    mutate(inhabitants = map2(inhabitants, food_ratio, reproduce),
           inhabitants = map2(inhabitants, food_ratio, die),
           n_inhabitants = map_int(inhabitants, nrow)) %>%
    filter(n_inhabitants > 0)
}

out <- c()

pop.test <- population %>% unnest
for(i in 1:100){
  pop.test <- pop.test  %>% birth_death()
  out <- c(out, pop.test %>% select(n_inhabitants) %>% sum)
}

```


```{r}
carrying.capacity <- 100
degredation.factor <- 1
regeneration.rate <- 0.0844
depletion.rate <- 0.5
production_elasticity <- 0.2

soil.dynamics <- function(x, population){
  x + regeneration.rate * x * (x / carrying.capacity) ^ degredation.factor * (1 - x / carrying.capacity) - depletion.rate * population
}

soil <- 100
for(i in 1:100){
  newsoil <- soil.dynamics(soil[i], 3)  
  if(newsoil < 0){newsoil <- 0}
  soil <- c(soil, newsoil)
}
plot(soil)
```



```{r}
land.req <- function(population, rent = .3){
  produce <- yield - seed.req
  hectares <- calorie.req * population / (produce * (1 - rent)) 
  total.rent <- hectares * rent * produce
  return(data_frame(hectares, total.rent))
}
```
