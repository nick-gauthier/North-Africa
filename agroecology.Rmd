---
title: "Agroecological Dynamics"
output: 
  html_document: 
    highlight: haddock
    keep_md: yes
---
Agent-based model of Roman land use and agroecology in North Africa
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T)
```
# Setup
Import necessary packages
```{r libraries, message = F, warning = F}
library(raster)  # for raster manipulation
library(MODIS) # land cover data
library(tidyverse) # for data manipulation and plotting
library(mgcv) # for fitting functions to data
library(viridis) # for color palettes
library(gridExtra)
```

# Modules
First we define key functions dealing with farming, soil dynamics, and demography.

### Soil Dynamics

Define parameters controlling the soil fertility dynamics.
```{r soil_parameters}
carrying.capacity <- 100
degradation <- tibble(type = c('reversible', 'hysteresis', 'irreversible'), 
                      degradation_factor = c(0, 1, 2),
                      regeneration_rate = c(0.05, 0.0844, 0.11880))
depletion.rate <- 0.25 # .25  to represent biennial fallow, .5 otherwise
```

Soil fertility dynamics
```{r soili-dynamics}
soil.dynamics <- function(x, population, soil.type = 'reversible'){
  params <- filter(degradation, type == soil.type)
  params$regeneration_rate * x * (x / carrying.capacity) ^ params$degradation_factor * (1 - x / carrying.capacity) - depletion.rate * population
}
```

So if you have 3 or more households per sq km (or 6 or more households practicing biennial fallow) then the soil will always deplete.
```{r echo = F}
expand.grid(fertility = 0:100, population = 0:3, soil.type = degradation$type, stringsAsFactors = F) %>%
  mutate(rate = pmap_dbl(list(fertility, population, soil.type), soil.dynamics)) %>%
  mutate(soil.type = factor(soil.type, levels = c('reversible', 'hysteresis', 'irreversible'))) %>%
  ggplot(aes(fertility, rate, group = as.factor(population))) +
  facet_wrap(~soil.type) +
  geom_line(aes(color = population)) +
    geom_hline(yintercept = 0, linetype = 2) +
  labs(title = 'Impact of population density on soil fertility change', x = 'Soil fertility (%)', y = 'Rate of fertility change') +
  theme_minimal()
```

### Farming
Agents determine how much land they need, calculate the yields from their land, remember these yields, and harvest from the land.

First define some parameters relating to food production and consumption.
```{r food_params}
max.yield <- 2000 # maximum possible wheat yield, in kg/ha

calorie.req <- 2582 * 365  # annual individual calorie requirement, derived from daily requirement
wheat.calories <- 3320 # calories in a kg of wheat
wheat.cal.proportion <- 0.75 # percent of individual's food calories coming from wheat
wheat.req <- calorie.req / wheat.calories * wheat.cal.proportion # kg of wheat to feed a person for 1 year

sowing_rate <- 135  # kg of wheat to sow a hectare (range 108 - 135 from Roman agronomists)
seed_proportion <- 135 / max.yield # proportion of harvest to save as seed for next year's sowing

labor.per.hectare <- 40 # person days per hectare
max.ag.labor <- 300 # maximum days per year an individual can devote to farming
max.memory <- 15 # maximum number of years a household remembers
production_elasticity <- 0.2
```

Crop yields are determined by rainfall and soil fertility.
```{r yields}
yield <- function(fertility, precipitation){
  f.reduction <- pmax(0, 0.19 * log(fertility / 100) + 1)  # fertility impact on yields
  p.reduction <- pmax(0, 0.51 * log(precipitation) + 1.03)  # annual precipitation impact on yields
  return(max.yield * f.reduction  * p.reduction)
} 
#todo, replace with gams!
```


```{r echo=F, fig.wdith = 8}
p1 <- tibble(fertility = 1:100, yield = yield(fertility, 1)) %>%
  ggplot(aes(fertility, yield)) +
  geom_line() +
  scale_y_continuous(limits = c(0,3000)) +
  labs(title = 'Soil fertility impact on wheat yield', subtitle = 'Assuming 1m annual precipitation',
       x = 'Soil Fertility (%)', y = 'Wheat Yield (kg/ha)') +
  theme_minimal()

p2 <- tibble(precipitation = seq(0, 2, .1), yield = yield(100, precipitation)) %>%
  ggplot(aes(precipitation, yield)) +
  geom_line() +
  scale_y_continuous(limits = c(0,3000)) +
  labs(title = 'Precipitation impact on wheat yield', subtitle = 'Assuming 100% soil fertility',
       x = 'Annual Precipitation (m)', y = 'Wheat Yield (kg/ha)') +
  theme_minimal()

grid.arrange(p1, p2, ncol = 2)
```

How agents decide the amount of land they need to farm. The determination of how much land is needed is a function of the household's occupants and labor availability.
```{r land_req}
land.req <- function(population, yield, laborers, fallow = T){
  land <- wheat.req * population * (1 + seed_proportion) / yield * ifelse(fallow, 2, 1)
  pmin(land, max.ag.labor * laborers / labor.per.hectare) # constrain by maximum hectares per household 
}
```

```{r echo=F}
bind_rows(tibble(n = 1:20, land = land.req(n, max.yield, 3, fallow = F), Management = 'No Fallow'),
          tibble(n = 1:20, land = land.req(n, max.yield, 3), Management = 'Fallow')) %>%
ggplot(aes(n, land, color = Management)) +
  geom_line() + 
  labs(title = 'Household size and land requirements', subtitle = 'Assuming yield of 2,000 kg/ha', 
       x = 'Household Size (inhabitants)', y = 'Farm land requirement (ha)') +
  theme_minimal()
```

```{r farm_funs}
farm <- function(households){
  households %>%
    mutate(land = land.req(n_inhabitants, peak_end(yield_memory), laborers),
           yield = this.yield,
           yield_memory = map2(.data$yield_memory, .data$yield, remember),
           harvest = land * this.yield) #%>%
    #select(-land, -yield)
}

remember <- function(yield_memory, yield){
  yield_memory <- c(yield, yield_memory)
  if(length(yield_memory) > max.memory) yield_memory <- yield_memory[1:15]
  return(yield_memory)
}
```



Agents use the peak-end rule when accessing memory.
```{r}
peak_end <- function(x){
  map_dbl(x, ~mean(c(.x[1], min(.x))))
}
```

Finally eat the harvested food, updating storage and food_ratio accordingly
```{r}
eat <- function(households){
  households %>%
    mutate(total.cal.req = n_inhabitants * wheat.req,
           food_ratio = (storage + harvest) / total.cal.req,
           old.storage = storage,
           storage = if_else(total.cal.req <= storage, harvest, pmax(harvest - (total.cal.req - old.storage), 0))) %>%
    select(-old.storage, -total.cal.req, -harvest)
}
```


### Demography

Generate fertility and mortality tables from pre-prepared data.
```{r birth-death}
fertility_table <- tibble(
  age = 10:49,
  rate = rep(c(0.022, 0.232, 0.343, 0.367, 0.293, 0.218, 0.216, 0.134), each = 5)
)
mortality_table <- tibble(
  age = c(0:84),
  rate = c(0.4669, rep(0.0702, 4), rep(c(0.0132, 0.0099, 0.0154, 0.0172, 0.0195, 0.0223, 0.0259, 0.0306, 0.0373, 0.0473, 0.0573, 0.0784, 0.1042, 0.1434, 0.2039, 0.2654), each = 5))
)
```

```{r echo = F}
ggplot(mortality_table, aes(age, rate)) +
  geom_line(color = 'red') +
  geom_line(data = fertility_table, color = 'blue') +
  labs(title = 'Fertility and Mortality Rates', subtitle = 'Per capita fertility (blue) and mortality (red) in the Roman Empire', x = 'Age', y = 'Vital rate') +
  theme_bw()
```

Calculate functions for vital rate elasticities from pre-prepared data.
```{r vital-rate-elasticity}
fertility_elasticity <- read_csv('data/fertility_data.csv', skip = 1) %>% 
  rename(food_ratio = X, fertility_reduction = Y) %>%
  gam(fertility_reduction ~ s(food_ratio), dat = .)
mort_elast <- read_csv('data/mortality_dataset.csv', skip = 1)

survivorship_elasticity <- bind_rows(
    mort_elast[1:2] %>% mutate(age = 1) %>% rename(food_ratio = X, mortality_reduction = Y), 
    mort_elast[3:4] %>% mutate(age = 25) %>% rename(food_ratio = X_1, mortality_reduction = Y_1),
    mort_elast[5:6] %>% mutate(age = 5) %>% rename(food_ratio = X_2, mortality_reduction = Y_2),
    mort_elast[7:8] %>% mutate(age = 65) %>% rename(food_ratio = X_3, mortality_reduction = Y_3)
  ) %>%
  group_by(age) %>%
  nest %>% 
  mutate(model = map(data, ~gam(mortality_reduction ~ s(food_ratio), dat = .))) %>%
  select(-data) %>%
  arrange(age) %>%
  slice(c(rep(1, 5), rep(2, 20), rep(3, 40), rep(4, 20))) %>%
  mutate(age = 0:84)
```

```{r echo = F}
plot(fertility_elasticity)
```

Birth
```{r reproduction}
reproduce <- function(inhabitants, food_ratio){
  fertility_reduction <- ifelse(food_ratio >= 1, 1, predict(fertility_elasticity, list(food_ratio = food_ratio)))
  
  babies <- inhabitants %>%
    filter(age >= 12 & age < 50) %>% # only individuals of child bearing age reproduce
    inner_join(fertility_table, by = 'age') %>%  # find the fertility rate corresponding to the individual's age
    mutate(baby = (rate / 2 * fertility_reduction) > runif(n())) %>%  # divide by two to make everyone female ...
    .$baby %>% # select just the babies column
    sum  # add it up to determine the number of newborns in the house
  
  if(babies > 0) inhabitants <- add_row(inhabitants, age = rep(0, babies))
  return(inhabitants)
}
```

Death
```{r}
die <- function(inhabitants, food_ratio){
  inhabitants %>%
    inner_join(mortality_table, by = 'age') %>%
    inner_join(survivorship_elasticity, by = 'age') %>%
    mutate(survivorship_reduction = ifelse(food_ratio >= 1, 1, map_dbl(model, ~predict(.x, list(food_ratio = food_ratio)))),
           dead = ((1 - rate) * survivorship_reduction) < runif(n())) %>%
    filter(dead == F) %>%
    select(age)
}
```

Agents first reproduce, then die, then age, and finally remove households with no inhabiants.
```{r}
birth_death <- function(households){
  households %>%
    mutate(inhabitants = map2(inhabitants, food_ratio, reproduce),
           inhabitants = map2(inhabitants, food_ratio, die),
           inhabitants = map(inhabitants, ~mutate(.x, age = age + 1)),
           n_inhabitants = map_int(inhabitants, nrow),
           laborers = map_dbl(inhabitants, ~filter(.x, age >= 20 & age < 45) %>% nrow)) %>%
    filter(n_inhabitants > 0)
}
```


# Simulation
Start with the populaiton level parameters, i.e. how many settlements, households, and individuals to start the simulation with.

```{r pop_params}
init_settlements <- 1 
init_households <- 3
init_inhabitants <- 2
init_age <- 25
```

Create a 2 villages of 10 households with 6 people in each.
```{r}
create.households <- function(x){
  tibble(household = 1:x,
         n_inhabitants = init_inhabitants,
         storage = n_inhabitants * wheat.req,
         yield_memory = c(max.yield),
         food_ratio = 1) %>%
    mutate(inhabitants = map(n_inhabitants, create.inhabitants),
           laborers = map_dbl(inhabitants, ~filter(.x, age >= 20 & age < 45) %>% nrow))
}

create.inhabitants <- function(x){
  tibble(age = rep(25, x))
}

population <- tibble(settlement = 1:init_settlements,
                     households = init_households) %>%
              mutate(households = map(households, create.households))
```

Test environment, generate simple raster to represent our environment
```{r eval = F}

sim.out <- tibble(year = 0, population = 0, fertility =  0, replicate = 0)
nsim <- 300
precip <- raster(nrow = 1, ncol = 1) %>% setValues(1)
pb <- txtProgressBar(min = 0, max = nsim, style = 3)

for(j in 1:10){
soil <- raster(nrow = 1, ncol = 1) %>% setValues(100)
test <- population$households[[1]]
for(i in 1:nsim){
  this.yield <- overlay(soil, precip, fun = yield) %>% getValues() * .5 # *.5 for fallow
test <- test%>% 
  farm %>%
  eat %>%
  birth_death

soil <- soil + soil.dynamics(soil, nrow(test), 'reversible')
sim.out <- add_row(sim.out, year = i, population = sum(test$n_inhabitants), fertility = getValues(soil), replicate = j)
}
setTxtProgressBar(pb, j)

}
close(pb)
sim.out <- sim.out[-1,]


ggplot(sim.out, aes(year, population, group = replicate)) +
  geom_line(alpha = .2) +
  theme_minimal()

ggplot(sim.out, aes(year, fertility, group = replicate)) +
  geom_line(alpha = .2) +
  theme_minimal()

test

```

# Environment

## Input data

Set a bounding box for the study area.
```{r bbox}
bbox <- extent(5, 11.5, 34, 37.5)
```

Import SRTM GDEM data for the elevation basemap.
```{r elevation}
elevation <- raster('~/gdrive/Data/SRTM_1km.tif') %>% crop(bbox)
elev_dat <- as.data.frame(elevation, xy =  T, na.rm = T) %>%
  rename(elevation = SRTM_1km)
```

```{r echo = F}
p1 <- ggplot(elev_dat, aes(x, y)) +
  geom_raster(aes(fill = elevation)) +
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Meters', guide = 'legend', breaks = seq(500,2000,500)) +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Elevation') +
  theme(legend.position='bottom')
```

Calculate slope in degrees from the SRTM elevation.
```{r slope}
slope <- terrain(elevation, opt = 'slope', unit = 'degrees')
slope_dat <- as.data.frame(slope, xy = T, na.rm = T)
```

```{r echo = F}
p2 <- ggplot(slope_dat, aes(x, y)) +
  geom_raster(aes(fill = slope)) +
  scale_fill_viridis(name = 'Degrees', option = 'B', guide = 'legend') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Slope') +
  theme(legend.position='bottom')
```

```{r}
grid.arrange(p1, p2, ncol = 2)
```


Where is arable land? Calculate the frequency of land with < 5 degree slope within 2.5 km.
```{r arable_land}
focalWeight(slope < 5, 0.008333333 * 2, type = 'circle') %>%
  focal(slope < 5, ., sum) %>%
  as.data.frame(xy = T, na.rm = T) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = layer)) +
  scale_fill_viridis(name = 'Proportion \narable land') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Arable land')
```

Now import temperature and precipitation data.
```{r climate}
prec <- brick('data/CHELSA/prec_1km.tif') %>% sum
gdd5 <- raster('data/CHELSA/gdd5_1km.tif')

prec_dat <- as.data.frame(prec, xy = T, na.rm = T)
gdd5_dat <- as.data.frame(gdd5, xy = T, na.rm = T)
```

```{r echo = F}
p1 <- ggplot(prec_dat, aes(x, y)) +
  geom_raster(aes(fill = layer)) +
  scale_fill_distiller(name = 'Millimeters', palette = 'YlGnBu', direction = 1, guide = 'legend', breaks = c(250, 500, 750, 1000)) +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Annual Precipitation') +
  theme(legend.position='bottom')

p2 <- ggplot(gdd5_dat, aes(x, y)) +
  geom_raster(aes(fill = gdd5_1km)) +
  scale_fill_distiller(name = 'Degree Days', palette = 'YlOrRd', direction = 1, guide = 'legend') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Growing Degree Days') +
  theme(legend.position='bottom')

grid.arrange(p1, p2, ncol = 2)
```
Soils
```{r}
soils <- merge(raster('data/soils/TAXNWRB_1km_Tunisia.tiff') %>% crop(bbox),
               raster('data/soils/TAXNWRB_1km_Algeria.tiff') %>% crop(bbox), tolerance = .3)
soils_dat <- as.data.frame(soils, xy =  T, na.rm = T) %>%
  rename(type = layer) %>%
  mutate(type = as.factor(type))
```

```{r echo = F}
ggplot(soils_dat, aes(x, y)) +
  geom_raster(aes(fill = type)) +
  scale_fill_brewer(type = 'qual', name = 'Soil type') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Soils')
```


Vegetation
```{r vegetation}
pft <- raster('data/MODIS/MCD12Q1.051_20170918110118/MCD12Q1.A2001001.Land_Cover_Type_5.tif') %>%
  projectRaster(disaggregate(elevation, 2), method = 'ngb') %>%
  as.data.frame(xy = T, na.rm = T) %>%
    rename(pft = MCD12Q1.A2001001.Land_Cover_Type_5) %>%
  #filter(!pft %in% c(0, 7:10)) %>%
  mutate(pft = recode_factor(as.factor(pft),
                               `0` = 'Water',
                               `1` = 'Evergreen Needleleaf trees',
                               `2` = 'Evergreen Broadleaf trees',
                               `3` = 'Deciduous Needleleaf trees',
                               `4` = 'Deciduous Broadleaf trees',
                               `5` = 'Shrub',
                               `6` = 'Grass',
                               `7` = 'Cereal crops',
                               `8` = 'Broad-leaf crops',
                               `9` = 'Urban and built-up',
                               `10` =	'Snow and ice',
                               `11` = 'Barren or sparse vegetation'))
```

```{r echo = F}
lc_colors <- c('#000080', '#008000', '#00FF00', '#99CC00', '#99FF99', '#FFCC99', '#FF9900', '#FFFF00', '#999966', '#FF0000', '#FFFFFF', '#808080') 

# colors inspired by https://lpdaac.usgs.gov/about/news_archive/modisterra_land_cover_types_yearly_l3_global_005deg_cmg_mod12c1
ggplot(pft, aes(x, y)) + 
  geom_tile(aes(fill = pft)) + 
  scale_fill_manual(values = lc_colors) + 
  theme_void() +
  coord_quickmap() +
  labs(title = 'Vegetation distribution')
```

Let's put all these environmental rasters together in a single brick for easier access.
```{r}
environment <- brick(slope, prec, gdd5)
```

