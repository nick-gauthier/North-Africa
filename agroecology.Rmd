---
title: "Agroecological Dynamics"
output: 
  html_document: 
    highlight: haddock
    keep_md: yes
---
Agent-based model of Roman land use and agroecology in North Africa
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T)
```
# Setup
Import necessary packages
```{r libraries, message = F, warning = F}
library(raster)  # for raster manipulation
library(MODIS) # land cover data
library(tidyverse) # for data manipulation and plotting
library(mgcv) # for fitting functions to data
library(viridis) # for color palettes
library(gridExtra) # for arranging plots
library(parallel) # for parallelization
```

# Modules
First we define key functions dealing with farming, soil dynamics, and demography.

### Soil Dynamics

Define parameters controlling the soil fertility dynamics.
```{r soil_parameters, eval=FALSE, include=FALSE}
carrying.capacity <- 100
degradation <- tibble(type = c('reversible', 'hysteresis', 'irreversible'), 
                      degradation_factor = c(0, 1, 2),
                      regeneration_rate = c(0.05, 0.0844, 0.11880))
depletion.rate <- 0.25 # .25  to represent biennial fallow, .5 otherwise
```

Soil fertility dynamics
```{r soil-dynamics, eval=FALSE, include=FALSE}
soil.dynamics <- function(x, population, soil.type = 'reversible'){
  params <- filter(degradation, type == soil.type)
  params$regeneration_rate * x * (x / carrying.capacity) ^ params$degradation_factor * (1 - x / carrying.capacity) - depletion.rate 
}
```

So if you have 3 or more households per sq km (or 6 or more households practicing biennial fallow) then the soil will always deplete.
```{r eval=FALSE, include=FALSE}
expand.grid(fertility = 0:100, population = 0:5, soil.type = degradation$type, stringsAsFactors = F) %>%
  mutate(rate = pmap_dbl(list(fertility, population, soil.type), soil.dynamics)) %>%
  mutate(soil.type = factor(soil.type, levels = c('reversible', 'hysteresis', 'irreversible'))) %>%
  ggplot(aes(fertility, rate, group = as.factor(population))) +
  facet_wrap(~soil.type) +
  geom_line(aes(color = population)) +
    geom_hline(yintercept = 0, linetype = 2) +
  labs(title = 'Impact of population density on soil fertility change', x = 'Soil fertility (%)', y = 'Rate of fertility change') +
  theme_minimal()
```
### Time Allocation
```{r}

allocate_time <- function(p = 1, b = 1, lf, j = 0.3, q = 0, r = 1, k = 0.4, a = 1, w = 0.2, le = 1 - lf){
  p * b * lf ^ j * (q + r) ^ k * a ^ (1 - j - k) + w * le
}

expand.grid(lf = seq(0,1,.01), q = seq(0,1,.01), r = c(.1, .5, 1)) %>%
  mutate(utility = pmap_dbl(list(lf = lf, q = q, r = r), allocate_time)) %>%
  ggplot(aes(lf, utility, group = q, color  = q)) +
  geom_line() +
  facet_wrap(~as.factor(r)) +
  theme_minimal()
```
```{r}
p = 1
b = 1
j = 0.3
q = 0
r = 1
k = 0.4
a = 1
w = 0.2
l <- 1
psi <- .2
e <- .125
qmax <- 1
#region 1
(j * p * b * a ^ (1-j-k) * r ^ k / w) ^ (1/(1-j))

#region 2
1 / (j + k) * (k * l + j * (psi - e) - 2 * j * e * r / qmax)

#region 3
psi - e

######
allocate_time <- function(p = 1, b = 1, j = 0.3, r = 1, k = 0.4, a = 1){

}
```

```{r}
maintain_infra <- function(lm, psi = .2, epsilon = .18, imax = 1){
  ifelse(0 <= lm & lm < (psi - epsilon), 0,
  ifelse((psi - epsilon) <= lm & lm <= (psi + epsilon), imax / (2 * epsilon) * (lm - psi + epsilon), imax))
}
psi = .2; epsilon = .18
tibble(lf = seq(0, 1, .001), i = maintain_infra(lf)) %>%
  ggplot(aes(lf, i)) +
    geom_vline(xintercept = psi + epsilon, linetype = 2, color = 'grey') +
  geom_line() +
  labs(title = 'Impact of infrastructure maintainance on performance',
       x = 'Labor devoted to maintaining infrastructure', y = 'Infrastructure performance') +
  theme_minimal()
```


### Farming
Agents determine how much land they need, calculate the yields from their land, remember these yields, and harvest from the land.

First define some parameters relating to food production and consumption.
```{r food_params}
max.yield <- 1500 # maximum possible wheat yield, in kg/ha, should range from 1000 - 2000

calorie.req <- 2582 * 365  # annual individual calorie requirement, derived from daily requirement
wheat.calories <- 3320 # calories in a kg of wheat
wheat.cal.proportion <- 0.75 # percent of individual's food calories coming from wheat
wheat.req <- calorie.req / wheat.calories * wheat.cal.proportion # kg of wheat to feed a person for 1 year

sowing_rate <- 135  # kg of wheat to sow a hectare (range 108 - 135 from Roman agronomists)
seed_proportion <- 135 / max.yield # proportion of harvest to save as seed for next year's sowing

labor.per.hectare <- 40 # person days per hectare
max.ag.labor <- 300 # maximum days per year an individual can devote to farming
max.memory <- 15 # maximum number of years a household remembers
production_elasticity <- 0.2
```

Crop yields are determined by rainfall and soil fertility.
```{r yields}
calc_climatic_yield <- function(precipitation){
  max.yield * pmax(0, 0.51 * log(precipitation) + 1.03)  # annual precipitation impact on yields
}

calc_yield_reduction <- function(fertility, climate_yield){
  f.reduction <- pmax(0, 0.19 * log(fertility / 100) + 1)  # fertility impact on yields
  return(f.reduction  * climate_yield)
} 
#todo, replace with gams!
```


```{r echo=F, fig.wdith = 8}
p1 <- tibble(fertility = 1:100, yield = calc_yield_reduction(fertility, 2000)) %>%
  ggplot(aes(fertility, yield)) +
  geom_line() +
  scale_y_continuous(limits = c(0,3000)) +
  labs(title = 'Soil fertility impact on wheat yield', subtitle = 'Assuming 1m annual precipitation',
       x = 'Soil Fertility (%)', y = 'Wheat Yield (kg/ha)') +
  theme_minimal()

p2 <- tibble(precipitation = seq(0, 2, .1), yield = calc_climatic_yield(precipitation)) %>%
  ggplot(aes(precipitation, yield)) +
  geom_line() +
  scale_y_continuous(limits = c(0,3000)) +
  labs(title = 'Precipitation impact on wheat yield', subtitle = 'Assuming 100% soil fertility',
       x = 'Annual Precipitation (m)', y = 'Wheat Yield (kg/ha)') +
  theme_minimal()

grid.arrange(p1, p2, ncol = 2)
```

How agents decide the amount of land they need to farm. The determination of how much land is needed is a function of the household's occupants and labor availability.
```{r land_req}
land.req <- function(population, yield, laborers, fallow = T){
  land <- wheat.req * population * (1 + seed_proportion) / yield * ifelse(fallow, 2, 1)
  pmin(land, max.ag.labor * laborers * ifelse(fallow, 2, 1) / labor.per.hectare) # constrain by maximum hectares per household 
}
```

```{r echo=F}
bind_rows(tibble(n = 1:20, land = land.req(n, max.yield, 3, fallow = F), Management = 'No Fallow'),
          tibble(n = 1:20, land = land.req(n, max.yield, 3, fallow = T), Management = 'Fallow')) %>%
ggplot(aes(n, land, color = Management)) +
  geom_line() + 
  labs(title = 'Household size and land requirements', subtitle = 'Assuming yield of 2,000 kg/ha', 
       x = 'Household Size (inhabitants)', y = 'Farm land requirement (ha)') +
  theme_minimal()
```

Here households calculate how much land they need, pull the crop yield from the environment, remember the yield, and determine their harvests by multiplying the yield by the amount of land they have (also removing some of the crop to save as seed for next year).

first, for dev purposes, make a fake environment raster.
```{r}
allocate_land <- function(households, arable_proportion){
  households %>% 
   mutate(land_req = 5, #land.req(n_inhabitants, peak_end(yield_memory), laborers),
          total_land_req = sum(land_req),
          land = if_else(total_land_req < (arable_proportion * 100), land_req, land_req / total_land_req * arable_proportion * 100)) %>%
    select(-land_req, -total_land_req)
}
```

```{r farm_funs}
farm <- function(households, climatic_yield){
  households %>%
    mutate(yield = calc_yield_reduction(soil_fertility, climatic_yield) * 0.5,
           yield_memory = map2(.data$yield_memory, .data$yield, remember),
           harvest = land * yield - land * sowing_rate,
           soil_fertility = 100)#soil_fertility + soil.dynamics(soil_fertility, laborers, 'reversible'))
}
```

```{r remember}
remember <- function(yield_memory, yield){
  yield_memory <- rnorm(1, yield, yield * 0.0333) %>%  #memory is fuzzy
    c(yield_memory)
  if(length(yield_memory) > max.memory) yield_memory <- yield_memory[1:max.memory]
  return(yield_memory)
}
```

Agents use the peak-end rule when accessing memory.
```{r}
peak_end <- function(x){
  map_dbl(x, ~mean(c(.x[1], min(.x))))
}
```

```{r}
random.series <- rnorm(100, mean = 200, sd = 50)
mem <- c()
for(i in 1:100){
  mem <- c(mem, mean(c(random.series[i], min(random.series[i:(min(i+14, 100))]))))  
}
qplot(x = 1:100, y = rev(random.series), geom = 'line') +
  geom_line(aes(y = rev(mem)), color = 'red', linetype = 2) +
  labs(x = 'Year', y = 'Crop Yield', title = 'Impact of peak-end rule on yield memory', subtitle = 'Randomly generated crop yields (black) and resulting "memory" (red), given a 15 year memory length') +
  theme_minimal()
```

Finally eat the harvested food, updating storage and food_ratio accordingly
```{r}
eat <- function(households){
  households %>%
    mutate(total.cal.req = n_inhabitants * wheat.req,
           food_ratio = (storage + harvest) / total.cal.req,
           old.storage = storage,
           storage = if_else(total.cal.req <= storage, harvest, pmax(harvest - (total.cal.req - old.storage), 0))) %>%
    select(-old.storage, -total.cal.req, -harvest)
}
```

### Demography

Generate fertility and mortality tables from pre-prepared data.
```{r birth-death}
fertility_table <- tibble(
  age = 10:49,
  rate = rep(c(0.022, 0.232, 0.343, 0.367, 0.293, 0.218, 0.216, 0.134), each = 5)
)
mortality_table <- tibble(
  age = c(0:84),
  rate = c(0.4669, rep(0.0702, 4), rep(c(0.0132, 0.0099, 0.0154, 0.0172, 0.0195, 0.0223, 0.0259, 0.0306, 0.0373, 0.0473, 0.0573, 0.0784, 0.1042, 0.1434, 0.2039, 0.2654), each = 5))
)
```

```{r echo = F}
ggplot(mortality_table, aes(age, rate)) +
  geom_line(color = 'red') +
  geom_line(data = fertility_table, color = 'blue') +
  labs(title = 'Fertility and Mortality Rates', subtitle = 'Per capita fertility (blue) and mortality (red) in the Roman Empire', x = 'Age', y = 'Vital rate') +
  theme_bw()
```

Calculate functions for vital rate elasticities from pre-prepared data.
```{r vital-rate-elasticity, warning = F, message = F}
fertility_elasticity <- read_csv('data/fertility_data.csv', skip = 1) %>% 
  rename(food_ratio = X, fertility_reduction = Y) %>%
  gam(fertility_reduction ~ s(food_ratio), dat = .)
mort_elast <- read_csv('data/mortality_dataset.csv', skip = 1)

survivorship_elasticity <- bind_rows(
    mort_elast[1:2] %>% mutate(age = 1) %>% rename(food_ratio = X, mortality_reduction = Y), 
    mort_elast[3:4] %>% mutate(age = 25) %>% rename(food_ratio = X_1, mortality_reduction = Y_1),
    mort_elast[5:6] %>% mutate(age = 5) %>% rename(food_ratio = X_2, mortality_reduction = Y_2),
    mort_elast[7:8] %>% mutate(age = 65) %>% rename(food_ratio = X_3, mortality_reduction = Y_3)
  ) %>%
  group_by(age) %>%
  nest %>% 
  mutate(model = map(data, ~gam(mortality_reduction ~ s(food_ratio), dat = .))) %>%
  select(-data) %>%
  arrange(age) %>%
  slice(c(rep(1, 5), rep(2, 20), rep(3, 40), rep(4, 20))) %>%
  mutate(age = 0:84)
```

Birth
```{r reproduction}
reproduce <- function(inhabitants, food_ratio){
  fertility_reduction <- ifelse(food_ratio >= 1, 1, predict(fertility_elasticity, list(food_ratio = food_ratio)))
  
  babies <- inhabitants %>%
    filter(age >= 12 & age < 50) %>% # only individuals of child bearing age reproduce
    inner_join(fertility_table, by = 'age') %>%  # find the fertility rate corresponding to the individual's age
    mutate(baby = (rate / 2 * fertility_reduction) > runif(n())) %>%  # divide by two to make everyone female ...
    .$baby %>% # select just the babies column
    sum  # add it up to determine the number of newborns in the house
  
  if(babies > 0) inhabitants <- add_row(inhabitants, age = rep(0, babies))
  return(inhabitants)
}
```

Death
```{r}
die <- function(inhabitants, food_ratio){
  inhabitants %>%
    inner_join(mortality_table, by = 'age') %>%
    inner_join(survivorship_elasticity, by = 'age') %>%
    mutate(survivorship_reduction = ifelse(food_ratio >= 1, 1, map_dbl(model, ~predict(.x, list(food_ratio = food_ratio)))),
           dead = ((1 - rate) * survivorship_reduction) < runif(n())) %>%
    filter(dead == F) %>%
    select(age)
}
```

Agents first reproduce, then die, then age, and finally remove households with no inhabiants.
```{r birthdeath}
birth_death <- function(households){
  households %>%
    mutate(inhabitants = map2(inhabitants, food_ratio, reproduce),
           inhabitants = map2(inhabitants, food_ratio, die),
           inhabitants = map(inhabitants, ~mutate(.x, age = age + 1)),
           n_inhabitants = map_int(inhabitants, nrow),
           laborers = map_dbl(inhabitants, ~filter(.x, age >= 20 & age < 45) %>% nrow)) %>%
    filter(n_inhabitants > 0)
}
```

If households get larger than 10 inhabitants, they split into two.
```{r fission}
fission <- function(households){
  static.households <- households %>% 
    filter(n_inhabitants < 10)
  
  if(nrow(static.households) == nrow(households)){
    return(households)
  } else{
  tmp <- households %>%
    filter(n_inhabitants >= 10) %>% 
    mutate(indices = map(inhabitants, ~sample.int(nrow(.x), nrow(.x) * 0.5)))
  
  old <- tmp %>% mutate(storage = .5 * storage,
                       inhabitants = map2(inhabitants, indices, ~slice(.x, .y)),
                       n_inhabitants = map_int(inhabitants, nrow))
  
  new <- tmp %>% mutate(storage = .5 * storage,
                inhabitants = map2(inhabitants, test, ~slice(.x, -.y)),
                n_inhabitants = map_int(inhabitants, nrow))
  
  return(bind_rows(static.households, old, new) %>%
    mutate(n_inhabitants = map_int(inhabitants, nrow),
           laborers = map_dbl(inhabitants, ~filter(.x, age >= 20 & age < 45) %>% nrow)))
  }
}
```


# Simulation
Start with the populaiton level parameters, i.e. how many settlements, households, and individuals to start the simulation with.

```{r pop_params}
init_settlements <- 1 
init_households <- 5
init_inhabitants <- 3
```

Create a 2 villages of 10 households with 6 people in each.
```{r}
create.households <- function(x){
  tibble(household = 1:x,
         n_inhabitants = init_inhabitants,
         storage = n_inhabitants * wheat.req,
         yield_memory = c(max.yield),
         food_ratio = 1) %>%
    mutate(inhabitants = map(n_inhabitants, create.inhabitants),
           laborers = map_dbl(inhabitants, ~filter(.x, age >= 20 & age < 45) %>% nrow)) %>%
    mutate(soil_fertility = 100)
}

create.inhabitants <- function(x){
  tibble(age = round(runif(x, 1, 60)))
}

population <- tibble(settlement = 1:init_settlements,
                     x = 1, y = 1,
                     households = init_households) %>%
              mutate(households = map(households, create.households))
```

Make an environment data table. For now we'll keep it to dummy value for development and testing purposes, see the following section for a "real environment".

```{r}
environment <- tibble(x = 1, y = 1, arable_proportion = 1, precipitation = 1)
```
```{r}
# this function takes a settlement (tibble of households), and makes the households do stuff
household_dynamics <- function(settlement, arable_proportion, yield){
  settlement %>%
    allocate_land(arable_proportion) %>%
    farm(yield) %>%
    eat %>%
    birth_death #%>%
    #fission)
}

# this function takes the master dataframe and calculates the per patch climatic yields from per patch precipitation
environmental_dynamics <- function(population){
  population %>%
    mutate(yield = calc_climatic_yield(precipitation))
}
```

Calculate population totals for plotting
```{r}
calc_pop <- function(population){
  population %>% 
    unnest(households) %>% 
    select(n_inhabitants) %>% 
    sum
}
```

```{r}
nsim <- 500
replicates <- 3

sim.out <- tibble(year = 0, population = calc_pop(population), replicate = 0)

sim.out <- mclapply(1:replicates, mc.cores = 3, function(j){
  test <- population %>% left_join(environment)
  for(i in 1:nsim){
  test <- test %>% 
    environmental_dynamics %>%
    mutate(households = pmap(list(households, arable_proportion, yield), household_dynamics))
    

    sim.out <- add_row(sim.out, year = i, population = calc_pop(test), replicate = j)
  }
  return(sim.out)
}) %>% bind_rows


ggplot(sim.out, aes(year, population, group = replicate,color = as.factor(replicate))) +
  geom_smooth(alpha = .2) +
  theme_minimal()

sim.out %>%
  filter(year == nsim) %>%
  ggplot(aes(x = population)) +
  geom_density() +
  theme_minimal()
```

# Environment

## Input data

Set a bounding box for the study area.
```{r bbox}
bbox <- extent(5, 11.5, 34, 37.5)
```

Import SRTM GDEM data for the elevation basemap.
```{r elevation}
elevation <- raster('~/gdrive/Data/SRTM_1km.tif') %>% crop(bbox)
```

```{r echo = F}
elev_dat <- as.data.frame(elevation, xy =  T, na.rm = T) %>%
  rename(elevation = SRTM_1km)

p1 <- ggplot(elev_dat, aes(x, y)) +
  geom_raster(aes(fill = elevation)) +
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Meters', guide = 'legend', breaks = seq(500,2000,500)) +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Elevation') +
  theme(legend.position='bottom')
```

Calculate slope in degrees from 90m SRTM elevation (90m data from http://www.earthenv.org/DEM).
```{r slope}
elev.list <- list.files('data/topography/', pattern = 'bil$', full.names = T, recursive = T) %>%
  map(raster)
elev.list$fun <- mean

slope <- do.call(mosaic, elev.list) %>% 
  crop(bbox) %>%
  terrain(opt = 'slope', unit = 'degrees')
```

```{r echo = F}
p2 <-  aggregate(slope, fact = 10, fun = median) %>%
  as.data.frame(xy = T, na.rm = T) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = slope)) +
  scale_fill_viridis(name = 'Degrees', option = 'B', guide = 'legend') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Slope') +
  theme(legend.position='bottom')

grid.arrange(p1, p2, ncol = 2)
```


Where is arable land? Calculate the proportion of land with =< 5 degree slope. Also find land with slope between 5 and 15 degrees, as potential land for terracing.
```{r arable_land}
arable_proportion <- (slope <= 5) %>% 
  aggregate(fact = 10, fun = sum) %>% 
  mask(elevation) %>%
  `/`(100)

terraceable_proportion <- (slope > 5 & slope <= 15) %>% 
  aggregate(fact = 10, fun = sum) %>% 
  mask(elevation) %>%
  `/`(100)
```

```{r echo = F}
p1 <- as.data.frame(arable_proportion, xy = T, na.rm = T) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = layer)) +
  scale_fill_viridis(name = 'Proportion of\n arable land') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Arable land')

p2 <- as.data.frame(terraceable_proportion, xy = T, na.rm = T) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = layer)) +
  scale_fill_viridis(name = 'Proportion of land\n suitable for terracing') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Terrace-able land')

grid.arrange(p1, p2, ncol = 2)
```

Now import temperature and precipitation data.
```{r climate}
prec <- brick('data/CHELSA/prec_1km.tif') %>% sum
gdd5 <- raster('data/CHELSA/gdd5_1km.tif')

prec_dat <- as.data.frame(prec, xy = T, na.rm = T)
gdd5_dat <- as.data.frame(gdd5, xy = T, na.rm = T)
```

```{r echo = F}
p1 <- ggplot(prec_dat, aes(x, y)) +
  geom_raster(aes(fill = layer)) +
  scale_fill_distiller(name = 'Millimeters', palette = 'YlGnBu', direction = 1, guide = 'legend', breaks = c(250, 500, 750, 1000)) +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Annual Precipitation') +
  theme(legend.position='bottom')

p2 <- ggplot(gdd5_dat, aes(x, y)) +
  geom_raster(aes(fill = gdd5_1km)) +
  scale_fill_distiller(name = 'Degree Days', palette = 'YlOrRd', direction = 1, guide = 'legend') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Growing Degree Days') +
  theme(legend.position='bottom')

grid.arrange(p1, p2, ncol = 2)
```
Soils
```{r}
soils <- merge(raster('data/soils/TAXNWRB_1km_Tunisia.tiff') %>% crop(bbox),
               raster('data/soils/TAXNWRB_1km_Algeria.tiff') %>% crop(bbox), tolerance = .3)
soils_dat <- as.data.frame(soils, xy =  T, na.rm = T) %>%
  rename(type = layer) %>%
  mutate(type = as.factor(type))
```

```{r echo = F}
ggplot(soils_dat, aes(x, y)) +
  geom_raster(aes(fill = type)) +
  scale_fill_discrete(name = 'Soil type') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Soils')
```


Vegetation
```{r vegetation}
pft <- raster('data/MODIS/MCD12Q1.051_20170918110118/MCD12Q1.A2001001.Land_Cover_Type_5.tif') %>%
  projectRaster(disaggregate(elevation, 2), method = 'ngb') %>%
  as.data.frame(xy = T, na.rm = T) %>%
    rename(pft = MCD12Q1.A2001001.Land_Cover_Type_5) %>%
  #filter(!pft %in% c(0, 7:10)) %>%
  mutate(pft = recode_factor(as.factor(pft),
                               `0` = 'Water',
                               `1` = 'Evergreen Needleleaf trees',
                               `2` = 'Evergreen Broadleaf trees',
                               `3` = 'Deciduous Needleleaf trees',
                               `4` = 'Deciduous Broadleaf trees',
                               `5` = 'Shrub',
                               `6` = 'Grass',
                               `7` = 'Cereal crops',
                               `8` = 'Broad-leaf crops',
                               `9` = 'Urban and built-up',
                               `10` =	'Snow and ice',
                               `11` = 'Barren or sparse vegetation'))
```

```{r echo = F}
lc_colors <- c('#000080', '#008000', '#00FF00', '#99CC00', '#99FF99', '#FFCC99', '#FF9900', '#FFFF00', '#999966', '#FF0000', '#FFFFFF', '#808080') 

# colors inspired by https://lpdaac.usgs.gov/about/news_archive/modisterra_land_cover_types_yearly_l3_global_005deg_cmg_mod12c1
ggplot(pft, aes(x, y)) + 
  geom_tile(aes(fill = pft)) + 
  scale_fill_manual(values = lc_colors) + 
  theme_void() +
  coord_quickmap() +
  labs(title = 'Vegetation distribution')
```

Let's put all these environmental rasters together in a single brick for easier access.
```{r}
environment <- brick(slope, prec, gdd5)
```

