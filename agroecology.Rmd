---
title: "Agroecology_dyn"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(raster)
library(tidyverse)
library(mgcv)
```

```{r}
bbox <- extent(5, 11.5, 34, 37.5)
```

```{r}
elev <- raster('~/gdrive/Data/SRTM_1km.tif') %>% crop(bbox)
elev_dat <- as.data.frame(elev, xy =  T, na.rm = T) %>%
  rename(elev = SRTM_1km)

ggplot(elev_dat, aes(x, y)) +
  geom_raster(aes(fill = elev)) +
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Meters') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Elevation', subtitle = 'Africa Proconsularis')
```

```{r}
slope <- terrain(srtm, opt = 'slope', unit = 'degrees')
slope_dat <- as.data.frame(slope, xy = T, na.rm = T)

ggplot(slope_dat, aes(x, y)) +
  geom_raster(aes(fill = slope)) +
  scale_fill_viridis(name = 'Degrees', option = 'B') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Slope', subtitle = 'Africa Proconsularis')
```

```{r}
focalWeight(slope < 5, 0.008333333 * 2, type = 'circle') %>%
  focal(slope < 5, ., sum) %>%
  as.data.frame(xy = T, na.rm = T) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = layer)) +
  scale_fill_viridis(name = 'Proportion \narable land') +
  theme_void() +
  coord_quickmap() +
  labs(title = 'Arable land', subtitle = 'Africa Proconsularis')
```

```{r climate, cache = T}
import_chelsa <- function(x){
  list.files(x, full.names = T) %>% 
  stack %>%
  crop(bbox) %>%
  .[[c(1,5:12, 2:4)]]
}
prec <- import_chelsa('/media/nick/0327ee2a-8256-411c-8b81-4f099c20a7cf/CHELSA/prec/')
temp <- import_chelsa('/media/nick/0327ee2a-8256-411c-8b81-4f099c20a7cf/CHELSA/temp/') %>%
  `/`(10)

levelplot(prec)
levelplot(temp)
```

```{r}
gdd5_interp <- function(x){
  if(any(is.na(x))){return(NA)} else{
    daily <- gam(x ~ s(doy, bs = 'cc', k = 12), knots = list(doy = c(1, 366))) %>%
      predict.gam(data.frame(doy = 1:365)) 
    daily[daily < 5] <- 5
    return(sum(daily - 5))
  }
}

doy <-c(15, 46, 74, 105, 135, 166, 196, 227, 258, 288, 319, 349)
```

```{r eval = F}
beginCluster(4)
gdd5 <- clusterR(temp, calc, args = list(fun = gdd5_interp), export = 'doy')
endCluster()
writeRaster(gdd5, 'data/CHELSA/gdd5_1km.tif', overwrite = T)
```

```{r}
gdd5 <- raster('data/CHELSA/gdd5_1km.tif')
rasterVis::levelplot(gdd5)

plot(gdd5, mean(temp))
```

# Social Model
##Parameters
```{r}
calorie.req <- 212  # kg of wheat to feed a person for 1 year, assuming grain is 75% of diet
#sowing_rate <- 135  #108 # kg of wheat to sow a hectare
kg.to.calories <- 3320 # kcals in one kg of wheat
labor.per.hectare <- 40 # person days per hectare
max.ag.labor <- 300 # maximum days per year an individual can devote to farming
max.yield <- 2000
init_settlements <- 1 
init_households <- 3
init_inhabitants <- 6
init_age <- 25
carrying.capacity <- 100
degredation.factor <- 0 # c(2, 1, 0)
regeneration.rate <- 0.05 # c(0.1188, 0.0844, 0.05)
depletion.rate <- 0.5
production_elasticity <- 0.2
max.memory <- 15 # maximum number of years a household remembers
```

Create a 2 villages of 10 households with 6 people in each.
```{r}
create.households <- function(x){
  tibble(household = 1:x,
         n_inhabitants = init_inhabitants,
         storage = n_inhabitants * calorie.req,
         yield_memory = c(max.yield),
         food_ratio = 1) %>%
    mutate(inhabitants = map(n_inhabitants, create.inhabitants),
           laborers = map_dbl(inhabitants, ~filter(.x, age >= 20 & age < 45) %>% nrow))
}

create.inhabitants <- function(x){
  tibble(age = rep(25, x))
}

population <- tibble(settlement = 1:init_settlements,
                     households = init_households) %>%
              mutate(households = map(households, create.households))
```


```{r}
land.req <- function(population, yield, laborers){
  land <- calorie.req * population * (1 + 0) / yield
  pmin(land, max.ag.labor * laborers / labor.per.hectare) # constrain by maximum hectares per household 
}
```

```{r yields}
yield <- function(fertility, precipitation){
  f.reduction <- pmax(0, 0.19 * log(fertility / 100) + 1)  # fertility impact on yields
  p.reduction <- pmax(0, 0.51 * log(precipitation) + 1.03)  # annual precipitation impact on yields
  return(max.yield * f.reduction  * p.reduction)
} 
#todo, replace with gams!
```

```{r soili-dynamics}
soil.dynamics <- function(x, population){
  newsoil <- x + regeneration.rate * x * (x / carrying.capacity) ^ degredation.factor * (1 - x / carrying.capacity) - depletion.rate * population
  return(max(newsoil, 0))
}
```


```{r}
farm <- function(households){
  households %>%
    mutate(land = land.req(n_inhabitants, peak_end(yield_memory), laborers),
           yield = this.yield,
           yield_memory = map2(.data$yield_memory, .data$yield, remember),
           harvest = land * this.yield) #%>%
    #select(-land, -yield)
}
```


```{r}
eat <- function(households){
  households %>%
    mutate(total.cal.req = n_inhabitants * calorie.req,
           food_ratio = (storage + harvest) / total.cal.req,
           old.storage = storage,
           storage = if_else(total.cal.req <= storage, harvest, pmax(harvest - (total.cal.req - old.storage), 0))) %>%
    select(-old.storage, -total.cal.req, -harvest)
}

remember <- function(yield_memory, yield){
  yield_memory <- c(yield, yield_memory)
  if(length(yield_memory) > max.memory) yield_memory <- yield_memory[1:15]
  return(yield_memory)
}
```

```{r}
precip <- raster(nrow = 1, ncol = 1) %>% setValues(1)
soil <- raster(nrow = 1, ncol = 1) %>% setValues(100)
test <- population$households[[1]]
out <- c()
nsim <- 500
pb <- txtProgressBar(min = 0, max = nsim, style = 3)
for(i in 1:nsim){
  this.yield <- overlay(soil, precip, fun = yield) %>% getValues()
test <- test%>% 
  farm %>%
  eat %>%
  birth_death

soil <- soil.dynamics(soil, nrow(test))
out <- c(out, sum(test$n_inhabitants))
setTxtProgressBar(pb, i)
}
close(pb)
plot(out)
test
```



```{r}
peak_end <- function(x){
  map_dbl(x, ~mean(c(.x[1], min(.x))))
}
```


```{r birth-death}
fertility_table <- tibble(
  age = 10:49,
  rate = rep(c(0.022, 0.232, 0.343, 0.367, 0.293, 0.218, 0.216, 0.134), each = 5)
)

mortality_table <- tibble(
  age = c(0:84),
  rate = c(0.4669, rep(0.0702, 4), rep(c(0.0132, 0.0099, 0.0154, 0.0172, 0.0195, 0.0223, 0.0259, 0.0306, 0.0373, 0.0473, 0.0573, 0.0784, 0.1042, 0.1434, 0.2039, 0.2654), each = 5))
)

ggplot(mortality_table, aes(age, rate)) +
  geom_line(color = 'red') +
  geom_line(data = fertility_table, color = 'blue') +
  labs(title = 'Fertility and Mortality Rates', subtitle = 'Per capita fertility (blue) and mortality (red) in the Roman Empire', x = 'Age', y = 'Vital rate') +
  theme_bw()
```
https://stackoverflow.com/questions/38237350/repeating-rows-of-data-frame-in-dplyr#comment63896747_38237805

```{r vital-rate-elasticity}
fertility_elasticity <- read_csv('data/fertility_data.csv', skip = 1) %>% 
  rename(food_ratio = X, fertility_reduction = Y) %>%
  gam(fertility_reduction ~ s(food_ratio), dat = .)

mort_elast <- read_csv('data/mortality_dataset.csv', skip = 1)

survivorship_elasticity <- bind_rows(
    mort_elast[1:2] %>% mutate(age = 1) %>% rename(food_ratio = X, mortality_reduction = Y), 
    mort_elast[3:4] %>% mutate(age = 25) %>% rename(food_ratio = X_1, mortality_reduction = Y_1),
    mort_elast[5:6] %>% mutate(age = 5) %>% rename(food_ratio = X_2, mortality_reduction = Y_2),
    mort_elast[7:8] %>% mutate(age = 65) %>% rename(food_ratio = X_3, mortality_reduction = Y_3)
  ) %>%
  group_by(age) %>%
  nest %>% 
  mutate(model = map(data, ~gam(mortality_reduction ~ s(food_ratio), dat = .))) %>%
  select(-data) %>%
  arrange(age) %>%
  slice(c(rep(1, 5), rep(2, 20), rep(3, 40), rep(4, 20))) %>%
  mutate(age = 0:84)

plot(fertility_elasticity)
```

```{r reproduction}
reproduce <- function(inhabitants, food_ratio){
  fertility_reduction <- ifelse(food_ratio >= 1, 1, predict(fertility_elasticity, list(food_ratio = food_ratio)))
  
  babies <- inhabitants %>%
    filter(age >= 12 & age < 50) %>%   # only individuals of child bearing age reproduce
    inner_join(fertility_table, by = 'age') %>%    # find the fertility rate corresponding to the individual's age
    mutate(baby = (rate / 2 * fertility_reduction) > runif(n())) %>%  # divide by two to make everyone female ...
    .$baby %>% # select just the babies column
    sum  # add it up to determine the number of newborns in the house
  
  if(babies > 0) inhabitants <- add_row(inhabitants, age = rep(0, babies))
  return(inhabitants)
}
```

```{r}
die <- function(inhabitants, food_ratio){
  inhabitants %>%
    inner_join(mortality_table, by = 'age') %>%
    inner_join(survivorship_elasticity, by = 'age') %>%
    mutate(survivorship_reduction = ifelse(food_ratio >= 1, 1, map_dbl(model, ~predict(.x, list(food_ratio = food_ratio)))),
           dead = ((1 - rate) * survivorship_reduction) < runif(n())) %>%
    filter(dead == F) %>%
    select(age)
}
```


```{r}
birth_death <- function(households){
  households %>%
    mutate(inhabitants = map2(inhabitants, food_ratio, reproduce),
           inhabitants = map2(inhabitants, food_ratio, die),
           inhabitants = map(inhabitants, ~mutate(.x, age = age + 1)),
           n_inhabitants = map_int(inhabitants, nrow),
           laborers = map_dbl(inhabitants, ~filter(.x, age >= 20 & age < 45) %>% nrow)) %>%
    filter(n_inhabitants > 0)
}

out <- c()
pop.test <- population %>% unnest %>% mutate(food_ratio = .8)
for(i in 1:100){
  pop.test <- pop.test  %>% birth_death()
  out <- c(out, pop.test %>% select(n_inhabitants) %>% sum)
}
plot(out)
```





